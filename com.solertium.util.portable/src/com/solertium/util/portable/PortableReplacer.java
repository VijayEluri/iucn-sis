/*
 * Copyright (C) 2007-2009 Solertium Corporation
 *
 * This file is part of the open source GoGoEgo project.
 *
 * Unless you have been granted a different license in writing by the
 * copyright holders for GoGoEgo, you may only modify or redistribute
 * this code under the terms of one of the following licenses:
 * 
 * 1) The Eclipse Public License, v.1.0
 *    http://www.eclipse.org/legal/epl-v10.html
 *
 * 2) The GNU General Public License, version 2 or later
 *    http://www.gnu.org/licenses
 */

package com.solertium.util.portable;

public class PortableReplacer {

	/**
	 * True if the supplied strings contains the ASCII Latin letters a-z or A-Z.
	 */
	public static boolean containsLetters(final String in) {
		for (int i = 0; i < in.length(); i++) {
			final char c = in.charAt(i);
			if ((c >= 'A') && (c <= 'Z'))
				return true;
			if ((c >= 'a') && (c <= 'z'))
				return true;
		}
		return false;
	}

	/**
	 * A specal purpose variant for escaping HTML/XML angle bracket tags where
	 * they would cause trouble
	 */
	public static String escapeTags(String in) {
		in = replace(in, "&", "&amp;");
		in = replace(in, "<", "&lt;");
		in = replace(in, ">", "&gt;");
		in = replace(in, "\"", "&quot;");
		in = replace(in, "'", "&apos;");
		return in;
	}

	public static String removeHTMLComments(String in) {
		StringBuilder inbuff = new StringBuilder();
		int startIndex = 0;
		while (startIndex > -1) {
			int index = in.indexOf("<!--", startIndex);
			if (index > -1) {
				int lastIndex = in.indexOf("-->", index + 4);
				if (lastIndex != -1) {
					inbuff.append(in.substring(startIndex, index));
					startIndex = lastIndex + 3;
				} else {
					inbuff.append(in.substring(startIndex, in.length()));
					startIndex = -1;
				}
			} else {
				inbuff.append(in.substring(startIndex, in.length()));
				startIndex = -1;
			}

		}
		return inbuff.toString();
	}

	/**
	 * (New) internal workhorse method; operates on a string to do a single
	 * token replacement.
	 */
	public static String replace(String in, String token, String value) {
		// short circuit eliminates NPEs here
		if (in == null || token == null || value == null || "".equals(token) || // token
																				// is
																				// empty
				in.indexOf(token) == -1) { // token is not present
			return in;
		}
		int found;
		int last = 0;

		// allocate space for at least 1 replacement
		// a second replacement may require reallocation of string buff size
		StringBuffer newsb = new StringBuffer(in.length() + value.length() + 4);

		do {
			found = in.indexOf(token, last);
			if (found > -1) {
				newsb.append(in.substring(last, found));
				newsb.append(value);
				last = found + token.length();
			}
		} while (found > -1);
		newsb.append(in.substring(last));

		return newsb.toString();
	}

	/**
	 * Limits HTML tags to only simple (em,strong,p,br,div) by running it
	 * through a TagFilter. Not the most efficient possible solution for this
	 * problem, but beats the heck out of many popular alternatives. Consider
	 * processing streams directly in your own performance-critical code.
	 */
	public static String simplifyTags(final String in) {
		if (in == null)
			return null;
		final StringBuffer ss = new StringBuffer(in.length());
		final PortableSimpleTagListener stl = new PortableSimpleTagListener();
		final PortableTagFilter filter = new PortableTagFilter(in, ss);
		filter.shortCircuitClosingTags = false;
		filter.registerListener(stl);
		filter.parse();
		String out = PortableReplacer.stripWhitespace(ss.toString());
		int ctr = 0;
		try { // attempt to remove leading/trailing junk generated by WYSIWYG
			while (out.startsWith("<p/>")) {
				out = out.substring(4);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("<p>")) {
				out = out.substring(0, out.length() - 3);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("<p/>")) {
				out = out.substring(0, out.length() - 4);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("<br/>")) {
				out = out.substring(0, out.length() - 5);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("&nbsp;")) {
				out = out.substring(0, out.length() - 6);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("<p></p>")) {
				out = out.substring(0, out.length() - 7);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
			while (out.endsWith("<br><br/>")) {
				out = out.substring(0, out.length() - 9);
				ctr++;
				if (ctr > 100)
					break; // infinite loop protection
			}
		} catch (final Exception ignored) {
		}
		out = PortableReplacer.replace(out, "&nbsp;", "&#160;"); // illegal xhtml
		// entity killer
		return out;
	}

	/**
	 * Removes any non-alphanumeric characters (A-Za-z0-9), including spaces
	 */
	public static String stripNonalphanumeric(String in) {
		// avoid NPE
		if (in == null)
			return null;
		StringBuffer buff = new StringBuffer(in.length());
		for (int i = 0; i < in.length(); i++) {
			char c = in.charAt(i);
			if ((c >= 'a') && (c <= 'z'))
				buff.append(c);
			else if ((c >= 'A') && (c <= 'Z'))
				buff.append(c);
			else if ((c >= '0') && (c <= '9'))
				buff.append(c);
		}
		return buff.toString();
	}

	public static String stripNonalphanumeric(String in, char[] explictlyAllowed) {
		if (in == null)
			return null;
		StringBuffer buff = new StringBuffer(in.length());
		for (int i = 0; i < in.length(); i++) {
			char c = in.charAt(i);
			if ((c >= 'a') && (c <= 'z'))
				buff.append(c);
			else if ((c >= 'A') && (c <= 'Z'))
				buff.append(c);
			else if ((c >= '0') && (c <= '9'))
				buff.append(c);
			else
				for (int k = 0; k < explictlyAllowed.length; k++)
					if (explictlyAllowed[k] == c)
						buff.append(c);
		}
		return buff.toString();
	}

	/**
	 * Removes any non-word characters (A-Za-z), including spaces
	 */
	public static String stripNonword(String in) {
		// avoid NPE
		if (in == null)
			return null;
		StringBuffer buff = new StringBuffer(in.length());
		int i;
		for (i = 0; i < in.length(); i++) {
			char c = in.charAt(i);
			if ((c >= 'a') && (c <= 'z')) {
				buff.append(c);
			} else if ((c >= 'A') && (c <= 'Z')) {
				buff.append(c);
			}
		}
		return buff.toString();
	}

	/**
	 * Removes leading or trailing whitespace of any type (spaces, newlines,
	 * tabs) -- not unlike Perl "chomp."
	 */
	public static String stripWhitespace(final String in) {
		// avoid NPE
		if (in == null)
			return null;
		int i;
		LOOP1: for (i = 0; i < in.length(); i++) {
			final char c = in.charAt(i);
			switch (c) {
			case ' ':
			case '\n':
			case '\r':
			case '\t':
				break;
			default:
				break LOOP1;
			}
		}
		int j;
		LOOP2: for (j = in.length() - 1; j > i; j--) {
			final char c = in.charAt(j);
			switch (c) {
			case ' ':
			case '\n':
			case '\r':
			case '\t':
				break;
			default:
				break LOOP2;
			}
		}
		return in.substring(i, j + 1);
	}

}
