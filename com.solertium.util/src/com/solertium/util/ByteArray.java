/*
 * Dedicated to the public domain by the author, Rob Heittman,
 * Solertium Corporation, January 2008
 * 
 * http://creativecommons.org/licenses/publicdomain/
 */

package com.solertium.util;

import java.io.Serializable;

/**
 * This utility class allows byte arrays to be manipulated as hexadecimal
 * representations in a String. This allows safe transport of the array in a
 * number of circumstances without falling prey to encoding problems. Hex String
 * encoding is not particularly efficient, of course, so use of this class
 * should be limited to small byte arrays.
 * 
 * @author <a href="mailto:rob.heittman@solertium.com">Rob Heittman</a>, <a
 *         href="http://www.solertium.com">Solertium Corporation</a>
 */
public class ByteArray implements Serializable {
	private static final long serialVersionUID = 1L;
	private final String hexRepresentation;

	/**
	 * Constructs this object with the supplied array of bytes. This constructor
	 * causes the internal hex representation String to be allocated.
	 * 
	 * @param a
	 *            the byte array to be wrapped by this class
	 */
	public ByteArray(final byte[] a) {
		final StringBuilder sb = new StringBuilder(a.length);
		for (final byte element : a) {
			final String s = Integer.toHexString(element & 0xFF);
			if(s.length()==1) sb.append(0);
			sb.append(s);
		}
		hexRepresentation = sb.toString();
	}

	/**
	 * Constructs this object with the supplied String which hopefully contains
	 * a hex representation of a byte array. This constructor attempts to
	 * convert the representation to byte[] immediately, throwing
	 * NumberFormatException if it is not valid hex.
	 * 
	 * @param s
	 *            the hex String to be wrapped by this class
	 * @throws NumberFormatException
	 *             when bad String input is supplied
	 */
	public ByteArray(final String s) throws NumberFormatException {
		hexRepresentation = s;
		checkArray();
	}

	/**
	 * CheckArray does the same as toArray() but does not allocate anything. Its
	 * purpose is to throw NumberFormatException if a bad string is supplied.
	 * 
	 * @throws NumberFormatException
	 */
	private void checkArray() throws NumberFormatException {
		for (int i = 0; i < length(); i++) {
			Integer.valueOf(hexRepresentation.substring(2 * i, 2 * i + 2), 16)
					.byteValue();
		}
	}

	/**
	 * Equality comparison is possible with other ByteArrays, as well as byte[]
	 * and String types.
	 */
	@Override
	public boolean equals(final Object obj) {
		if (obj instanceof ByteArray)
			return hexRepresentation.equalsIgnoreCase(((ByteArray) obj)
					.toString());
		else if (obj instanceof String)
			return hexRepresentation.equalsIgnoreCase((String) obj);
		else if (obj instanceof byte[])
			return equals(new ByteArray((byte[]) obj));
		else
			return false;
	}

	/**
	 * The hashCode contract is fulfilled by returning the object hash of the
	 * underlying String.
	 */
	@Override
	public int hashCode() {
		return hexRepresentation.hashCode();
	}

	/**
	 * This returns the number of bytes <b>in the resultant byte array.</b> For
	 * the length of the hex-encoded String representation, use
	 * toString().length(). toArray().length is semantically equivalent to this
	 * method, but less efficient.
	 * 
	 * @return the length in bytes of the underlying array
	 */
	public int length() {
		return hexRepresentation.length() / 2;
	}

	/**
	 * Returns a byte array corresponding to the stored hex representation. This
	 * causes a new byte array to be generated on each invocation.
	 * 
	 * @return the generated byte array
	 */
	public byte[] toArray() {
		final byte[] a = new byte[length()];
		for (int i = 0; i < a.length; i++) {
			a[i] = Integer.valueOf(
					hexRepresentation.substring(2 * i, 2 * i + 2), 16)
					.byteValue();
		}
		return a;
	}

	/**
	 * @return the String version of the stored hex representation.
	 */
	@Override
	public String toString() {
		return hexRepresentation;
	}
	
}
